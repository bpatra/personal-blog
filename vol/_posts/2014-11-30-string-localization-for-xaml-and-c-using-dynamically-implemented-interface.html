---
layout: post
status: publish
published: true
title: String localization for XAML and C# using dynamically implemented interface
author:
  display_name: Benoit Patra
  login: benoitpatra
  email: benoit.patra@gmail.com
  url: https://www.benoitpatra.com
author_login: benoitpatra
author_email: benoit.patra@gmail.com
author_url: https://www.benoitpatra.com
wordpress_id: 655
wordpress_url: http://benoitpatra.com/?p=655
date: '2014-11-30 11:51:19 +0000'
date_gmt: '2014-11-30 10:51:19 +0000'
categories:
- Programming
tags:
- C#
- Localization
- MSIL
- resharper
- Unit Testing
- WPF
- XAML
comments:
- id: 431
  author: My WPF/MVVM &#8220;must have&#8221; part 1/ 3 &#8211; working with design
    time data | Beno&icirc;t Patra&#039;s blog
  author_email: ''
  author_url: http://benoitpatra.com/2015/01/18/my-wpfmvvm-must-have-part-1-3-working-with-design-time-data/
  date: '2015-01-18 19:09:37 +0000'
  date_gmt: '2015-01-18 18:09:37 +0000'
  content: "[&#8230;] you create a multi lang app with the approach detailed in one
    of my previous posts you can change within the if(ViewModelBase.IsInDesignModeStatic)
    scope the CurrentUICulture to [&#8230;]"
- id: 441
  author: My WPF/MVVM &#8220;must have&#8221; part 2/ 3 &#8211; No Resharper binding
    error in XAML code | Beno&icirc;t Patra&#039;s blog
  author_email: ''
  author_url: http://benoitpatra.com/2015/04/07/my-wpfmvvm-must-have-part-2-3-no-resharper-binding-error-in-xaml-code/
  date: '2015-04-07 13:08:16 +0000'
  date_gmt: '2015-04-07 11:08:16 +0000'
  content: "[&#8230;] addition, this works very well&nbsp;with the strongly typed
    translation mechanism that I presented in this previous post. Remark&nbsp;that
    all available translations are now proposed by R# and if you try to use a non
    [&#8230;]"
---
<p>In this post I will describe a solution for easy localized strings management in XAML or C#. Precisely, we will use the usual recommended material for manipulating localized strings in .NET: resx files and the <a href="http://msdn.microsoft.com/en-us/library/system.resources.resourcemanager%28v=vs.110%29.aspx">ResourceManager</a> class. However, for XAML manipulation, we will add a "type layer" on top of this. We will see that having typed resources can be very useful. The "type layer" is basically an interface where string properties contain the localized strings, then in XAML or C# code the translations are accessed by using directly these properties. To avoid painful repetitions, the implementation of the interface is dynamically generated using some very simple <a href="http://en.wikipedia.org/wiki/Common_Intermediate_Language">MSIL</a>. To conclude, we will write simple unit tests that check that the translation files (.resx) contains all the localized strings for all supported languages.</p>
<p>First, let us recall that it is really important that your localized strings are not dispersed in the source code of your application. Using a code snippet of the following form is a bad practice.</p>
<p>[code language="csharp"]<br />
//don't do this<br />
TextBox.Text = LocalizeUtil.Localize("Hello","Bonjour","Bon dia");<br />
[/code]</p>
<p>Indeed, it is very important that you keep grouped all the translations for a given language in one file. Then, you could rework your translations on your own or with a professional without having to grep the entire code base.</p>
<p>Fortunately, .NET comes with all the material you need to handle Culture-Specific resources with the <a href="http://msdn.microsoft.com/en-us/library/system.resources.resourcemanager%28v=vs.110%29.aspx">ResourceManager</a>. Say you support english (default) and french languages then you have two .resx files which contains key/value string entries. Such files are named <em>LocalizedStrings.resx</em> and <em>LocalizedStrings.fr-FR.resx</em> they may contain, among others, the entry <em>SayHello</em> ("Hello!" in english and "Bonjour !" in french). Finally, you only have to initialize the <em>ResourceManager</em> and getting the localized strings as follows.</p>
<p>[code language="csharp"]<br />
var rem = new ResourceManager("LocalizedStrings", Assembly.GetExecutingAssembly());<br />
Console.WriteLine(rem.GetString("SayHello"));<br />
[/code]</p>
<p>It is important to note that the right file (<em>*.resx</em> or <em>*.fr-FR.resx</em>) is automatically chosen using the <em>Tread.CurrentThread.CurrentUICulture</em>.</p>
<p>When manipulating XAML for the UI of your app, creating a type for the localized string is recommended. Indeed, in XAML you can bind to properties but you cannot (at least not easily) bind to methods. So the <a href="http://msdn.microsoft.com/en-us/library/dd882554%28VS.95%29.aspx">recommended method from the MSDN</a> is to create a LocalizedStrings class whose members are the localized strings.</p>
<p>So we can create the LocalizedStrings class</p>
<p>[code language="csharp"]<br />
public class LocalizedStrings<br />
{<br />
    private readonly ResourceManager _rem<br />
    public LocalizedStrings(ResourceManager rem)<br />
    {<br />
        _rem = rem;<br />
    }</p>
<p>    public string SayHello<br />
    {<br />
       { get {return _rem.GetString("SayHello"); }<br />
    }</p>
<p>    public string SayHelloAgain<br />
    {<br />
       { get {return _rem.GetString("SayHelloAgain"); }<br />
    }</p>
<p>    /* A lot of properties more..... */<br />
}<br />
[/code]</p>
<p>While the instance is retrieved using a Singleton-like pattern (there is no reason to mock this for testing so it makes sense to use a singleton here).<br />
[code language="csharp"]<br />
public class StringLocalizer<br />
{<br />
    private static LocalizedStrings _localizedStrings;</p>
<p>    public static LocalizedStrings Strings<br />
    {<br />
        get<br />
        {<br />
            if (_localizedStrings == null)<br />
            {<br />
                  _localizedStrings = new LocalizedStrings(new ResourceManager("LocalizedStrings", Assembly.GetExecutingAssembly())));<br />
             }<br />
             return _localizedStrings;<br />
        }<br />
     }<br />
}<br />
[/code]</p>
<p>We can use easily the LocalizedStrings in the xaml after adding the StringLocalizer has an application resource.<br />
[code language="xml"]<br />
<!-- set the localizer has a resource --><br />
 <Application.Resources><br />
   <local:StringLocalizer xmlns:local ="clr-namespace:appNamespace"<br />
                           x:Key="Localizer" /><br />
 </Application.Resources><br />
 <!-- in the window or user control --><br />
 <Button DockPanel.Dock="Left"<br />
         Command="{Binding Next}"<br />
         ToolTip="{Binding Strings.SayHello, Source={StaticResource Localizer}}"><br />
[/code]</p>
<p>Obviously we can use the same class in the plain old C#<br />
[code language="csharp"]<br />
Console.WriteLine(StringLocalizer.Strings.SayHello);<br />
[/code]</p>
<p>Using this "type layer" is not only mandatory for XAML it is also very useful because we benefit from the static typing. Indeed, typing help us to create localized strings list that do not contain tons on unused entries. Even if this is not a matter of life or death, it is a good thing to remove unused localized strings from your dictionaries, because they going to cost you some effort or money when you will make new languages available or if you want to review the terminology used in your application. The only thing you have to do is to search for unused member of the class (the plugin <a href="https://www.jetbrains.com/resharper/">Resharper</a> does this well even in XAML).</p>
<p>As shown in the image below the XAML-intellisense of Resharper shows us all members of the interface which is handy to reuse localized strings.<br />
[caption id="attachment_664" align="aligncenter" width="625"]<a href="/wp-content/uploads/2014/11/resharperlistofusedentries.jpg"><img class="wp-image-664 size-large" src="/wp-content/uploads/2014/11/resharperlistofusedentries.jpg?w=625" alt="The plugins resharper shows all properties of the LocalizedStrings class" width="625" height="559" /></a> The plugins resharper shows all properties of the LocalizedStrings class[/caption]</p>
<p>Still there is one thing which is cumbersome, every-time you create a new entry you have to type the same logic for the property: <em>_rem.GetString("NameOfTheProperty")</em>. Then, it's time to be nerdy and find a way to do this automatically! Let us replace the <em>LocalizedStrings</em> class by and interface <em>ILocalizedStrings </em> whose implementation is dynamically generated. You can emit dynamically new type in .NET using the ILGenerator. So this is the implementation of the new <em>StringLocalizer</em> with some help from the .NET IL guru <a href="http://olivierguimbal.name/">Olivier Guimbal</a>.</p>
<p>So here it is what the interface looks like</p>
<p>[code language="csharp"]<br />
public interface ILocalizedStrings<br />
{<br />
    void SetResMan(ResourceManager man);</p>
<p>    string SayHello{ get; }<br />
    string SayHelloAgain{ get; }<br />
    /* A lot of properties more..... */<br />
}<br />
[/code]</p>
<p>And here is the StringLocalizer</p>
<p>[code language="csharp"]<br />
public class StringLocalizer<br />
{<br />
    private static class InstanceGenerator<br />
    {<br />
        static readonly Dictionary<Type, ILocalizedStrings> Implementations = new Dictionary<Type, ILocalizedStrings>();<br />
        static int _implCount = 0;</p>
<p>        static ModuleBuilder _moduleBuilder;<br />
        static ModuleBuilder ModuleBuilder<br />
        {<br />
            get<br />
            {<br />
                if (_moduleBuilder != null)<br />
                    return _moduleBuilder;<br />
                var assemblyName = new AssemblyName { Name = "Services" };<br />
                AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.RunAndSave);<br />
                _moduleBuilder = assemblyBuilder.DefineDynamicModule("ServicesModule", "ServicesModule.dll");<br />
                return _moduleBuilder;<br />
            }<br />
        }</p>
<p>        public static ILocalizedStrings CreateImplementation()<br />
        {<br />
            Type interfaceType = typeof(ILocalizedStrings);<br />
            if (!interfaceType.IsInterface)<br />
                throw new ArgumentException(interfaceType + " is not an interface type");</p>
<p>            ILocalizedStrings found;<br />
            if (Implementations.TryGetValue(interfaceType, out found))<br />
                return found;</p>
<p>            var module = ModuleBuilder;<br />
            var tb = module.DefineType(interfaceType.FullName + "Impl" + (_implCount++), TypeAttributes.Public | TypeAttributes.BeforeFieldInit, typeof(object), new[] { interfaceType });</p>
<p>            FieldBuilder fld = tb.DefineField("_resourceManager", typeof(ResourceManager), FieldAttributes.Private);</p>
<p>            var setter = tb.DefineMethod("SetResMan", MethodAttributes.Public | MethodAttributes.Virtual, CallingConventions.HasThis, typeof(void), new Type[] { typeof(ResourceManager) });<br />
            MethodInfo setMethodInfo = typeof(ILocalizedStrings).GetMethod("SetResMan");</p>
<p>            var setterIl = setter.GetILGenerator();<br />
            setterIl.Emit(OpCodes.Ldarg_0);<br />
            setterIl.Emit(OpCodes.Ldarg_1);<br />
            setterIl.Emit(OpCodes.Stfld, fld);<br />
            setterIl.Emit(OpCodes.Ret);</p>
<p>            tb.DefineMethodOverride(setter, setMethodInfo);</p>
<p>            var props = interfaceType.GetProperties();</p>
<p>            foreach (var pi in props)<br />
            {<br />
                if (pi.PropertyType != typeof(string))<br />
                    throw new ArgumentException("Only string properties are supported");</p>
<p>                if (pi.CanWrite)<br />
                    throw new ArgumentException("Property must be read-only: " + interfaceType + " -> " + pi.Name);</p>
<p>                MethodInfo methodInfo = pi.GetGetMethod();<br />
                var mb = CreateOverride(tb, methodInfo);</p>
<p>                var il = mb.GetILGenerator();<br />
                il.Emit(OpCodes.Ldarg_0);<br />
                il.Emit(OpCodes.Ldfld, fld);<br />
                il.Emit(OpCodes.Ldstr, pi.Name);<br />
                il.Emit(OpCodes.Call, typeof(ResourceManager).GetMethod("GetString", new[] { typeof(string) }));<br />
                il.Emit(OpCodes.Ret);</p>
<p>                PropertyBuilder pb = tb.DefineProperty(pi.Name,<br />
                       PropertyAttributes.HasDefault,<br />
                        CallingConventions.HasThis, methodInfo.ReturnType,<br />
                        methodInfo.GetParameters().Select(p => p.ParameterType).ToArray());<br />
                pb.SetGetMethod(mb);<br />
            }</p>
<p>            found = (ILocalizedStrings)Activator.CreateInstance(tb.CreateType());<br />
            Implementations.Add(interfaceType, found);<br />
            return found;<br />
        }</p>
<p>        static MethodBuilder CreateOverride(TypeBuilder tb, MethodInfo mi)<br />
        {<br />
            var mb = tb.DefineMethod(mi.Name,<br />
                        MethodAttributes.Public<br />
                        | MethodAttributes.HideBySig<br />
                        | MethodAttributes.NewSlot<br />
                        | MethodAttributes.Virtual<br />
                        | MethodAttributes.Final,<br />
                        CallingConventions.HasThis, mi.ReturnType, mi.GetParameters().Select(p => p.ParameterType).ToArray());<br />
            tb.DefineMethodOverride(mb, mi);</p>
<p>            return mb;<br />
        }<br />
    }</p>
<p>    private static ILocalizedStrings _localizedStrings;</p>
<p>    public static ILocalizedStrings Strings<br />
    {<br />
        get<br />
        {<br />
            if (_localizedStrings == null)<br />
            {<br />
                _localizedStrings = (ILocalizedStrings)InstanceGenerator.CreateImplementation();<br />
                _localizedStrings.SetResMan(new ResourceManager("LocalizedStrings", Assembly.GetExecutingAssembly())));<br />
            }<br />
         return _localizedStrings;<br />
        }<br />
    }<br />
}<br />
[/code]</p>
<p>[caption id="attachment_665" align="aligncenter" width="625"]<a href="/wp-content/uploads/2014/11/failingtest.png"><img class="wp-image-665 size-large" src="/wp-content/uploads/2014/11/failingtest.png?w=625" alt="Tests are failing because some properties of the ILocalizedStrings are missing in the resx." width="625" height="233" /></a> Tests are failing because there are some unused entries in the resx.[/caption]</p>
<p>To conclude let us write unit tests to ensure that all properties in the interface <em>ILocalizedStrings</em> are defined on all .resx files and, reciprocally, to make sure that all keys in the resx files are properties of the interface. This will help us to track non translated entries and to remove useless keys in the resx dictionaries. We basically parse the .resx files to retrieve all keys and use reflexion to get all public properties of the interface. The test fail when problematic entries are discovered and printed in the test console.</p>
<p>[code language="csharp"]<br />
[TestClass]<br />
public class TranslationTests<br />
{</p>
<p>   private TestContext _testContextInstance;<br />
   public TestContext TestContext<br />
   {<br />
       get<br />
       {<br />
           return _testContextInstance;<br />
       }<br />
       set<br />
       {<br />
           _testContextInstance = value;<br />
       }<br />
   }</p>
<p>   private void TestPropertiesAndResxKeyAreEqual(string filePath)<br />
   {<br />
       XDocument xDoc = XDocument.Load(filePath);</p>
<p>       HashSet<string> resxKeys = new HashSet<string>(xDoc.Descendants("data").Select(c => c.Attribute("name").Value));<br />
       HashSet<string> interfaceProp =<br />
           new HashSet<string>(<br />
               typeof (ILocalizedStrings).GetProperties(BindingFlags.Public | BindingFlags.Instance)<br />
                   .Select(p => p.Name));</p>
<p>       bool fail = false;<br />
       foreach (var r in resxKeys)<br />
       {<br />
           if (!interfaceProp.Contains(r))<br />
           {<br />
               _testContextInstance.WriteLine(string.Format("The key {0} exists in resx but not in interface", r));<br />
               fail = true;</p>
<p>           }<br />
       }</p>
<p>       foreach (var property in interfaceProp)<br />
       {<br />
           if (!resxKeys.Contains(property))<br />
           {<br />
               _testContextInstance.WriteLine(string.Format("The key {0} exists in interface but not in resx", property));<br />
               fail = true;<br />
           }<br />
       }<br />
       if (fail)<br />
       {<br />
           Assert.Fail();<br />
       }</p>
<p>   }</p>
<p>   [TestMethod]<br />
   public void TestEnglishResx()<br />
   {<br />
       const string path = @"../../../MyApp/LocalizedStrings.resx";<br />
       TestPropertiesAndResxKeyAreEqual(path);<br />
   }</p>
<p>   [TestMethod]<br />
   public void TestFrenchResx()<br />
   {<br />
       const string path = @"../../../MyApp/LocalizedStrings.fr-FR.resx";<br />
       TestPropertiesAndResxKeyAreEqual(path);<br />
   }<br />
}<br />
[/code]</p>
