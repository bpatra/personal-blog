---
layout: post
status: publish
published: true
title: A generic version of ICollectionView used in a MVVM searchable list
author:
  display_name: Benoit Patra
  login: benoitpatra
  email: benoit.patra@gmail.com
  url: https://www.benoitpatra.com
author_login: benoitpatra
author_email: benoit.patra@gmail.com
author_url: https://www.benoitpatra.com
wordpress_id: 608
wordpress_url: http://benoitpatra.com/?p=608
date: '2014-10-12 16:54:13 +0000'
date_gmt: '2014-10-12 14:54:13 +0000'
categories:
- Programming
- MVVM
tags:
- ".NET"
- C#
- MVVM
- resharper
- Unit Testing
- WPF
- XAML
comments:
- id: 34589
  author: Joe
  author_email: jmoleary@earthlink.net
  author_url: ''
  date: '2018-12-07 00:50:55 +0000'
  date_gmt: '2018-12-07 00:50:55 +0000'
  content: "I realize this is over 4 years since you posted it but I hope you might
    be willing to answer a question.  Have you used this very extensively?  Did it
    ever cause an exception for you.  Because it is for me and I'm not sure if I've
    used it incorrectly or not: \r\n\r\nI got the code from GitHub and used it it
    to try to expose a filtered ObservableCollection of one of my view-model types
    (\"ShapeVm\") as ICollectionView.   Unfortunately as my app added ShapeVm items
    to the the underlying ObservableCollection, I got an exception from WPF:\r\n\r\n\"An
    ItemsControl is inconsistent with its items source.  See the inner exception for
    more information\"  (I can state unequivocably right now I only ever modify the
    underlying collection from the main, UI thread.)\r\n\r\nThe inner exception had
    a very large message, specifically targeted for developers.  I'll paste it below
    in case you read this and think it matters.  But here is how I exposed the collection
    in my ViewModel\r\n\r\n        private ObservableCollection _shapes; // Initialized
    elsewhere\r\n        private CollectionView _orphanShapes;\r\n        public ICollectionView
    OrphanShapes => _orphanShapes ?? (_orphanShapes =\r\n            new MyCollectionViewGeneric(new
    CollectionViewSource(ShapeVms))\r\n            {\r\n                Filter =  MyFilterFunction;
    // defined elsewhere,  Only takes certain ShapeVms\r\n            });\r\n\r\nAnd
    here is the exception full message:\r\n\r\n\r\nInformation for developers (use
    Text Visualizer to read this):\r\nThis exception was thrown because the generator
    for control 'MyApp.Core.Shapes.ShapesControl Items.Count:2' with name 'BaseShapeItems'
    has received sequence of CollectionChanged events that do not agree with the current
    state of the Items collection.  The following differences were detected:\r\n  Accumulated
    count 3 is different from actual count 2.  [Accumulated count is (Count at last
    Reset + #Adds - #Removes since last Reset).]\r\n  At index 1:  Generator's item
    'MyApp.Core.Shapes.LineVm' is different from actual item 'MyApp.Core.Shapes.LineVm'.\r\n\r\nOne
    or more of the following sources may have raised the wrong events:\r\n     System.Windows.Controls.ItemContainerGenerator\r\n
    \     System.Windows.Controls.ItemCollection\r\n       MS.Internal.Data.CollectionViewProxy\r\n
    \ *     MyApp.Core.CollectionViewGeneric`1[[MyApp.Core.Shapes.ShapeVm, MyApp.Core,
    Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]\r\n         System.Collections.ObjectModel.ObservableCollection`1[[MyApp.Core.Shapes.ShapeVm,
    MyApp.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]\r\n(The starred
    sources are considered more likely to be the cause of the problem.)\r\n\r\nThe
    most common causes are (a) changing the collection or its Count without raising
    a corresponding event, and (b) raising an event with an incorrect index or item
    parameter.\r\n\r\nThe exception's stack trace describes how the inconsistencies
    were detected, not how they occurred.  To get a more timely exception, set the
    attached property 'PresentationTraceSources.TraceLevel' on the generator to value
    'High' and rerun the scenario.  One way to do this is to run a command similar
    to the following:\r\n   System.Diagnostics.PresentationTraceSources.SetTraceLevel(myItemsControl.ItemContainerGenerator,
    System.Diagnostics.PresentationTraceLevel.High)\r\nfrom the Immediate window.
    \ This causes the detection logic to run after every CollectionChanged event,
    so it will slow down the application.\r\n\r\n\r\nAny ideas?"
- id: 63957
  author: Benoit Patra Scks Homo Dick
  author_email: BenoitPatraIsSOB@sucksdick.com
  author_url: ''
  date: '2020-10-07 19:37:55 +0000'
  date_gmt: '2020-10-07 17:37:55 +0000'
  content: "This code really sucks the nigger dick\r\nwho is the unit inch goat humping
    cocksucker who posted this crapola\r\nHey Benoit Patra what muslim goat did you
    stick your unit incher when you faggot ass posted this trach"
---
<p>In this post we&nbsp;will describe how to create a searchable list with&nbsp;<a href="http://en.wikipedia.org/wiki/Windows_Presentation_Foundation">WPF</a> following <a href="http://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM </a>principles.&nbsp;To this aim we will use a WPF <em>ListView</em> to display the searched items and a <em>TextBox</em> to enter the text used for the search. Most of the implementation that you will find on the web (e.g. <a href="http://stackoverflow.com/questions/15473048/create-a-textboxsearch-to-filter-from-listview-wpf">this one)</a> will recommend you to bind your <em>ListView</em> to an <em>ICollectionView</em>. However, this is not 100% satisfactory&nbsp;as long as <em>ICollectionView</em> does not have a built-in generic version.&nbsp;Consequently&nbsp;the ViewModel's member exposing the binding items&nbsp;will return&nbsp;an&nbsp;<em>ICollectionView</em> which is a&nbsp;powerful object (see <a href="http://marlongrech.wordpress.com/2008/11/22/icollectionview-explained/">this for instance</a>)&nbsp;&nbsp;but is "only"&nbsp;an enumeration of&nbsp;<em>System.Object</em>. In this post we will show you that a generic version can be easily implemented and exposed by your ViewModel.</p>
<p>In this post we will create a very simple app that let you search a player in the list of all the players of the last Football World Cup in Brazil. The complete source code can be found on&nbsp;<a href="https://github.com/bpatra/MvvMSample">my Github here.</a></p>
<p>[caption id="attachment_613" align="aligncenter" width="300"]<a href="/assets/images/legacy-wp-content/2014/10/listview.jpg"><img class="wp-image-613 size-medium" src="/assets/images/legacy-wp-content/2014/10/listview.jpg?w=300" alt="Searchable WPF ListView" width="300" height="203" /></a> Searching 'dav' in the ListView display a list of results starting with ex Chelsea's player David Luis...[/caption]</p>
<p>The key ingredients of such implementation is very simple in MVVM. First take the View which&nbsp;does not need more than the few lines of xaml below.</p>
<p>[code language="xml"]<br />
 <UserControl.DataContext><br />
 <Binding Path="PlayerSearchViewModel" Source="{StaticResource Locator}" /><br />
</UserControl.DataContext><br />
<DockPanel><br />
 <TextBlock DockPanel.Dock="Top" Text="Search player"></TextBlock><br />
 <TextBox DockPanel.Dock="Top" Text="{Binding SearchPlayerText, UpdateSourceTrigger=PropertyChanged}"></TextBox><br />
<ListView ItemsSource="{Binding DisplayedPlayers}" SelectionMode="Single" ScrollViewer.VerticalScrollBarVisibility="Auto"><br />
  <ListView.View><br />
   <GridView ><br />
    <GridViewColumn DisplayMemberBinding="{Binding Name}" Header="Name" /><br />
    <GridViewColumn DisplayMemberBinding="{Binding NationalTeam}" Header="National Team" /><br />
    <GridViewColumn DisplayMemberBinding="{Binding Age}" Header="Age" /><br />
    <GridViewColumn DisplayMemberBinding="{Binding Club}" Header="Club"/><br />
    <GridViewColumn DisplayMemberBinding="{Binding Championship}" Header="Championship"/><br />
   </GridView><br />
  </ListView.View><br />
 </ListView><br />
</DockPanel><br />
[/code]</p>
<p>Let us start by exposing the non-generic version: the <em>DataContext</em> of the control above is bound to an instance of an implementation of the interface <em>IPlayerSearchViewModel</em> below.</p>
<p>[code language="csharp"]<br />
public interface IPlayerSearchViewModel<br />
{<br />
   string SearchPlayerText { get; set; }</p>
<p>   ICollectionView DisplayedPlayers { get; }<br />
}<br />
[/code]</p>
<p>A very straightforward implementation that works is the following one.</p>
<p>[code language="csharp"]<br />
public class PlayerSearchViewModel : IPlayerSearchViewModel<br />
{<br />
    private readonly ICollectionView _view;<br />
    private string _textsearch;</p>
<p>    public PlayerSearchViewModel(IPlayerProvider playerProvider)<br />
    {<br />
        _view = CollectionViewSource.GetDefaultView(playerProvider.GetAllWorldCupPlayer());<br />
        _view.Filter += (object item) =><br />
        {<br />
                    if (_textsearch == null) return true;<br />
                    var itemPl = (IPlayer) item;<br />
                    return itemPl.Name.Contains(_textsearch) ||<br />
                               itemPl.NationalTeam.Contains(_textsearch) ||<br />
                               itemPl.Club.Contains(_textsearch) ||<br />
                               itemPl.Championship.Contains(_textsearch);<br />
        };<br />
    }</p>
<p>    public string SearchPlayerText<br />
    {<br />
        get { return _textsearch; }<br />
        set<br />
        {<br />
            _textsearch = value;<br />
            _view.Refresh();<br />
        }<br />
    }</p>
<p>    public ICollectionView DisplayedPlayers { get { return _view; } }<br />
}<br />
[/code]</p>
<p>As I said in the introduction, this is quite enoying. You may want to create screens with many <em>ICollectionView</em> bindings that may contain different types, then it is becoming error prone and we are loosing the benefit of C#'s type safety. The unit test example below is showing you that the elements need to be casted while they are accessed from the <em>ICollectionView</em>.</p>
<p>[code language="csharp"]<br />
[TestMethod]<br />
public void TestingTheSearchingCapabilitiesWithBedoya()<br />
{<br />
    var viewModel = new PlayerSearchViewModel(new PlayerProvider());<br />
    viewModel.SearchPlayerText = "Bedoya";<br />
    var searchResult = viewModel.DisplayedPlayers.Cast<IPlayer>().ToArray(); //Cast objects extracted from the ICollectionView<br />
    Assert.AreEqual(1, searchResult.Length);<br />
    IPlayer bedoya = searchResult[0];<br />
    Assert.AreEqual("Nantes",bedoya.Club);<br />
}<br />
[/code]</p>
<p>In addition we cannot use anymore the XAML validation and intellisense provided by Resharper.</p>
<p>[caption id="attachment_618" align="aligncenter" width="625"]<a href="/assets/images/legacy-wp-content/2014/10/resharpercomplaining-e1450469349252.jpg"><img class="wp-image-618 size-large" src="/assets/images/legacy-wp-content/2014/10/resharpercomplaining-1024x195.jpg" alt="Resharper complaining because of the unknown's member of the DataContext (typed as object)" width="625" height="119" /></a> Resharper complaining because of the unknown's member of the DataContext (typed as object)[/caption]</p>
<p>Fortunately we can create our generic version of <em>ICollectionView</em> and get back to the comfortable world of type safety. In this example, I will only provide the generic enumeration and the generic version for the <em>SourceCollection</em> member but you can add others. Indeed, you may create a generic version of the <em>Filter</em> predicate to avoid dealing with <em>System.Object</em> in your lambdas but with your generic type <em>T</em> instead.</p>
<p>[code language="csharp"]<br />
public interface ICollectionView<T> : IEnumerable<T>, ICollectionView<br />
{<br />
    IEnumerable<T> SourceCollectionGeneric { get; }<br />
    //Add here your "generic methods" e.g.<br />
    //e.g. Predicate<T> Filter {get;set;} etc.<br />
}<br />
[/code]</p>
<p>Actually, the implementation of the <em>ICollectionView</em> is really easy as long as you already have the non-generic instance at hand <em>ICollectionView</em></p>
<p>[code language="csharp"]<br />
public class MyCollectionViewGeneric<T> : ICollectionView<T><br />
{<br />
    private readonly ICollectionView _collectionView;</p>
<p>    public MyCollectionViewGeneric(ICollectionView generic)<br />
    {<br />
        _collectionView = generic;<br />
    }</p>
<p>    private class MyEnumerator : IEnumerator<T><br />
    {<br />
        private readonly IEnumerator _enumerator;<br />
        public MyEnumerator(IEnumerator enumerator)<br />
        {<br />
            _enumerator = enumerator;<br />
        }</p>
<p>        public void Dispose()<br />
        {<br />
        }</p>
<p>        public bool MoveNext()<br />
        {<br />
            return _enumerator.MoveNext();<br />
        }</p>
<p>        public void Reset()<br />
        {<br />
            _enumerator.Reset();<br />
        }</p>
<p>        public T Current { get { return (T) _enumerator.Current; } }</p>
<p>        object IEnumerator.Current<br />
        {<br />
            get { return Current; }<br />
        }<br />
    }</p>
<p>    public IEnumerator<T> GetEnumerator()<br />
        {<br />
            return new MyEnumerator(_collectionView.GetEnumerator());<br />
        }</p>
<p>    IEnumerator IEnumerable.GetEnumerator()<br />
    {<br />
        return _collectionView.GetEnumerator();<br />
    }</p>
<p>    public bool Contains(object item)<br />
    {<br />
     return _collectionView.Contains(item);<br />
    }</p>
<p>    public void Refresh()<br />
    {<br />
        _collectionView.Refresh();<br />
    }</p>
<p>       //Complete implementation can be found on github.co/bpatra/MVVMSample</p>
<p>    public event NotifyCollectionChangedEventHandler CollectionChanged<br />
    {<br />
        add<br />
        {<br />
            lock (objectLock)<br />
            {<br />
                _collectionView.CollectionChanged += value;<br />
            }<br />
        }<br />
        remove<br />
        {<br />
            lock (objectLock)<br />
            {<br />
                _collectionView.CollectionChanged -= value;<br />
            }<br />
        }<br />
    }</p>
<p>    public IEnumerable<T> SourceCollectionGeneric</p>
<p>        get { return _collectionView.Cast<T>(); }<br />
    }<br />
}<br />
[/code]</p>
<p>Therefore the implementation of the the ViewModel becomes cleaner and statically typed. First the new version of the ViewModel interface.</p>
<p>[code language="csharp"]<br />
public interface IPlayerSearchViewModel<br />
{<br />
    string SearchPlayerText { get; set; }</p>
<p>    ICollectionView<IPlayer> DisplayedPlayers { get; }<br />
}<br />
[/code]</p>
<p>Then, the implementation.</p>
<p>[code language="csharp"]<br />
public class PlayerSearchViewModel : IPlayerSearchViewModel<br />
{<br />
    private readonly ICollectionView<IPlayer>; _view;<br />
    private string _textsearch;</p>
<p>    public PlayerSearchViewModel(IPlayerProvider playerProvider)<br />
    {<br />
        _view = new MyCollectionViewGeneric<IPlayer>;(CollectionViewSource.GetDefaultView(playerProvider.GetAllWorldCupPlayer()));<br />
        _view.Filter += (object item) =>;<br />
        {<br />
            if (_textsearch == null) return true;<br />
            var itemPl = (IPlayer) item;<br />
            return itemPl.Name.Contains(_textsearch) ||<br />
                        itemPl.NationalTeam.Contains(_textsearch) ||<br />
                        itemPl.Club.Contains(_textsearch) ||<br />
                        itemPl.Championship.Contains(_textsearch);<br />
        };<br />
    }</p>
<p>    public string SearchPlayerText<br />
    {<br />
    get { return _textsearch; }<br />
        set<br />
        {<br />
            _textsearch = value;<br />
            _view.Refresh();<br />
        }<br />
    }</p>
<p>    public ICollectionView<IPlayer>; DisplayedPlayers { get { return _view; } }<br />
}<br />
[/code]</p>
<p>You do not have to cast or worry anymore on the the type of the objects contained in you <em>ICollectionView</em>. You will also detect binding errors statically with Resharper.</p>
<p>[caption id="attachment_623" align="aligncenter" width="700"]<a href="/assets/images/legacy-wp-content/2014/10/resharperclever-e1450469370983.png"><img class="wp-image-623 size-full" src="/assets/images/legacy-wp-content/2014/10/resharperclever-e1450469370983.png" alt="resharperClever" width="700" height="450" /></a> Resharper handles typed generic collections in databinding[/caption]</p>
