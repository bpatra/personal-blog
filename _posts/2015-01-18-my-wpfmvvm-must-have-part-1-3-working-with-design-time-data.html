---
layout: post
status: publish
published: true
title: My WPF/MVVM "must have" part 1/ 3 - working with design time data
author:
  display_name: Benoit Patra
  login: benoitpatra
  email: benoit.patra@gmail.com
  url: https://www.benoitpatra.com
author_login: benoitpatra
author_email: benoit.patra@gmail.com
author_url: https://www.benoitpatra.com
wordpress_id: 695
wordpress_url: http://benoitpatra.com/?p=695
date: '2015-01-18 17:23:06 +0000'
date_gmt: '2015-01-18 16:23:06 +0000'
categories:
- Programming
- MVVM
tags:
- C#
- Design
- MVVM
- WPF
- XAML
comments:
- id: 451
  author: My WPF/MVVM &#8220;must have&#8221; part 2/ 3 &#8211; No Resharper binding
    error in XAML code | Beno&icirc;t Patra&#039;s blog
  author_email: ''
  author_url: http://benoitpatra.com/2015/04/07/my-wpfmvvm-must-have-part-2-3-no-resharper-binding-error-in-xaml-code/
  date: '2015-04-07 13:08:11 +0000'
  date_gmt: '2015-04-07 11:08:11 +0000'
  content: "[&#8230;] you have followed my previous post regarding WPF and MVVM, you
    saw&nbsp;that the ViewModels (VMs), consumed by the Views (composed essentially
    of XAML code), are [&#8230;]"
---
<p>This is the first post of a series in three parts where I will discuss what are the "must have" of any of my WPF/MVVM projects. This one is about dealing with design time data with the framework <a title="MVVM light" href="http://www.mvvmlight.net/">MVVM light.</a>&nbsp;The&nbsp;sample project of this post can be found <a href="https://github.com/bpatra/DesignableMVVMSample">here on my github</a>.</p>
<p>When we speak of design time data in a WPF project, we refer to the data that will be visible in the Visual Studio designer. In the picture below the data displayed have no reason to be related to production or any testing dataset. They serve <strong>the only purpose of designing your app</strong>. It is important to be aware that the Visual Studio designer is extremely powerful and is able to execute some of the .NET code of your app. I have noticed also that the VS WPF designer have improved a lot with VS 2012.</p>
<p>[caption id="attachment_701" align="aligncenter" width="625"]<a href="/wp-content/uploads/2015/01/visualstudiodesigner1-e1450469421814.jpg"><img class="wp-image-701 size-large" src="/wp-content/uploads/2015/01/visualstudiodesigner1-1024x439.jpg" alt="Visual Studio 2013 designer" width="625" height="268" /></a> Visual Studio 2013 designer[/caption]</p>
<p><em><strong>Why having design time data is ABSOLUTELY mandatory?</strong></em><br />
First, some controls do not need data to be designed. Take a <em>Button</em> for example, its <em>Content</em> (the label) is probably static then you will not have any troubles designing it. On the contrary, if you take the <em>DataGrid </em>in the screenshot above, the rows are dynamic data so you won't be able to see some lines in your VS designer unless you specify some design time data.</p>
<p>Now let me tell you a story. I learnt WPF because I was affected to an Excel addin project that had been started two years before. The screens had been developed using WPF but without any pattern, only (spaghetti) code behind. In addition to the fact that nothing was testable and the business logic was tightly coupled to the presentation, there was no design time data for the WPF screens. Sometimes, in order to view the effect of a single border color modification, the developer had to start the addin, connect some web services, fetch (potentially large) data etc... All of this was <strong>dramatic in term of efficiency</strong>. A complete reskin of the application was not even thinkable.&nbsp;Let me conclude this argumentation by saying that some data are <strong>not easily produced with a test dataset</strong>. For example, if you have a <em>Textblock</em> displaying a path on your hardrive. You would like to see if it is still ok if this path becomes very long. If you do not have design time data, you will have to create such a deep folder hierarchy in your drive, only to see the behavior of your <em>TextBlock </em> control style. This is a pity, using design time data, you may insert any string in the control in less than a second.</p>
<p><strong><em>How do you do that in practice with&nbsp;an MVVM project?</em></strong><br />
We are going to take a very simple sample project (that can be found <a href="https://github.com/bpatra/DesignableMVVMSample">here</a>). This application is a window with two tabs to display some information about book authors. You can select the author with a <em>Combobox</em>. On the first tab, there is basic information about the author while on the second tab there is the list of the books written by this author. Implementing this with MVVM: you will have three views (.xaml files): one the main window, two for the tabs.</p>
<p><a href="/wp-content/uploads/2015/01/application.jpg"><img class="aligncenter wp-image-704 size-medium" src="/wp-content/uploads/2015/01/application.jpg?w=300" alt="Sample book application" width="300" height="163" /></a></p>
<p>In my WPF apps, all view models are specified through interfaces. Then, for the sample project, we have the three following interfaces: <em>IMainViewModel</em>, <em>ISummaryTabViewModel </em>and <em>IBooksWrittenTabViewModel</em>.<br />
<em>ISummaryTabViewModel </em>and <em>IBooksWrittenTabViewModel </em>are "sub view models". Naturally, they are exposed as member of the <em>IMainViewModel</em>.</p>
<p>[code language="csharp"]<br />
public interface IMainViewModel<br />
{<br />
    IPerson SelectedPerson { get; set; }</p>
<p>    IList<IPerson> AvailablePersons { get; }</p>
<p>    ISummaryTabViewModel SummaryTabViewModel { get; }</p>
<p>    IBooksWrittenTabViewModel BooksWrittenTabViewModel { get; }<br />
}<br />
[/code]</p>
<p><strong>For each view model there are two implementations: </strong>the production implementation and the design implementation. I like to separate in another namespace the design time implementations to avoid "solution explorer visual pollution".</p>
<p>[caption id="attachment_706" align="aligncenter" width="300"]<a href="/wp-content/uploads/2015/01/solutionexplorer.jpg"><img class="size-medium wp-image-706" src="/wp-content/uploads/2015/01/solutionexplorer.jpg?w=300" alt="Visual Studio Solution Explorer with Design ViewModels" width="300" height="263" /></a> Visual Studio Solution Explorer with Design ViewModels[/caption]</p>
<p>We use a <em>ViewModelLocator</em> so that the views can find the appropriate implementation of the view model interface. Typically, the <em>ViewModelLocator</em> exposes a static property for the "top" rooted view model.</p>
<p>[code language="csharp"]<br />
public class ViewModelLocator<br />
{<br />
   private static readonly IKernel _kernel;<br />
   static ViewModelLocator()<br />
   {<br />
      _kernel = new StandardKernel();<br />
      if (ViewModelBase.IsInDesignModeStatic)<br />
      {<br />
           _kernel.Bind<IMainViewModel>().To<DesignMainViewModel>();<br />
       }<br />
       else<br />
       {<br />
           _kernel.Bind<IMainViewModel>().To<MainViewModel>().InSingletonScope();<br />
       }</p>
<p>   }<br />
   public static IMainViewModel MainViewModel { get { return _kernel.Get<IMainViewModel>(); } }<br />
}<br />
[/code]</p>
<p>In the sample above, I kept the IoC Ninject container (the <em>_kernel </em>field). You may ignore this but the <em>ViewModelLocator</em> is the composition root of the application, this is where an IoC Container should be used, <a href="http://msdn.microsoft.com/en-us/magazine/jj991965.aspx">see this post for more information</a>.</p>
<p>All the magic lies in the if statement <em>ViewModelBase.IsInDesignModeStatic</em> which is provided by the amazing <a href="http://www.mvvmlight.net/">MVVM Light Framework</a> developed by Laurent Bugnion. It will detect if the call to the <em>ViewModelLocator</em> comes from the Visual Studio Designer or if the application is truly running.</p>
<p>If you create a multi lang app with the approach detailed in <a href="/2014/11/30/string-localization-for-xaml-and-c-using-dynamically-implemented-interface/">one of my previous posts</a> you can change within the <em>if(ViewModelBase.IsInDesignModeStatic)</em> scope the <em>CurrentUICulture</em> to design and see your app with any supported languages.</p>
<p>Now the <em>ViewModelLocator</em> is manipulated in the views as follows<br />
In MainWindow.xaml</p>
<p>[code language="xml"]<br />
<Window x:Class="WpfApplication1.MainWindow"<br />
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"<br />
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"<br />
        xmlns:viewModel="clr-namespace:WpfApplication1.ViewModel"<br />
        xmlns:views="clr-namespace:WpfApplication1.Views"<br />
        Title="MainWindow" Height="350" Width="525"><br />
    <Window.DataContext><br />
        <Binding Path="MainViewModel" Source="{StaticResource Locator}" /><br />
    </Window.DataContext><br />
[/code]</p>
<p>In SummaryTabControl.xaml the control <em>DataContext</em> is bound to the <em>SummaryTabViewModel</em> property of the <em>IMainViewModel</em>.</p>
<p>[code language="xml"]<br />
<UserControl x:Class="WpfApplication1.Views.SummaryTabControl"<br />
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"<br />
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"<br />
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"<br />
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"<br />
             mc:Ignorable="d"<br />
             d:DesignHeight="300" d:DesignWidth="300"><br />
    <UserControl.DataContext><br />
        <Binding Path="MainViewModel.SummaryTabViewModel" Source="{StaticResource Locator}"/><br />
    </UserControl.DataContext><br />
[/code]</p>
<p>The <em>Locator</em> resource has been declared in the App.xaml</p>
<p>[code language="xml"]<br />
<Application x:Class="WpfApplication1.App" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" StartupUri="MainWindow.xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" d1p1:Ignorable="d" xmlns:d1p1="http://schemas.openxmlformats.org/markup-compatibility/2006"><br />
  <Application.Resources><br />
    <vm:ViewModelLocator x:Key="Locator" d:IsDataSource="True" xmlns:vm="clr-namespace:WpfApplication1.ViewModel" /><br />
  </Application.Resources><br />
</Application><br />
[/code]</p>
<p>Let us have a look at the <em>DesignMainViewModel</em> class</p>
<p>[code language="csharp"]<br />
public class DesignMainViewModel : IMainViewModel<br />
{<br />
   public static IPerson fakePerson = new Person()<br />
   {<br />
       Name = "Raymond Domenech",<br />
       Age = 62,<br />
       Books = new IBook[0]<br />
   };</p>
<p>   public static IPerson fakePerson2 = new Person()<br />
   {<br />
       Name = "Victor Hugo",<br />
       Age = 45,<br />
       Books = new IBook[0]<br />
   };</p>
<p>   public IPerson SelectedPerson<br />
   {<br />
       get<br />
       {<br />
           return fakePerson;<br />
       }<br />
       set<br />
       {<br />
           throw new NotImplementedException();<br />
       }<br />
   }</p>
<p>   public IList&amp;lt;IPerson> AvailablePersons<br />
   {<br />
       get {return new []{fakePerson, fakePerson2}; }<br />
   }</p>
<p>   public ISummaryTabViewModel SummaryTabViewModel<br />
   {<br />
       get { return new DesignSummaryTabViewModel(); }<br />
   }</p>
<p>   public IBooksWrittenTabViewModel BooksWrittenTabViewModel<br />
   {<br />
       get { return new DesignBooksWrittenTabViewModel(); }<br />
   }<br />
}<br />
[/code]</p>
<p>and the <em>SummaryTabViewModel</em> class</p>
<p>[code language="csharp"]<br />
class DesignSummaryTabViewModel : ISummaryTabViewModel<br />
{<br />
   public string Name { get { return "Raymond Domenech"; } }<br />
   public int Age { get { return 62; } }<br />
}<br />
[/code]</p>
<p>When implementing the "Design" view models it is important to avoid implementing any business logic. If the fake data are incoherent between the several view models design implementations that should not trouble you either. To conclude, in a real app, you will probably have to create design implementation not only for the view models but also for the objects used in data bindings (e.g. the interface IBook).</p>
<p>This is the end of the first part of the WPF/MVVM "must have" series. The second article will deal with the organization of the unit tests of an MVVM application.</p>
