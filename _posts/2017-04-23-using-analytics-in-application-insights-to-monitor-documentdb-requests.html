---
layout: post
status: publish
published: true
title: Using Analytics in Application Insights to monitor CosmosDB Requests
author:
  display_name: Benoit Patra
  login: benoitpatra
  email: benoit.patra@gmail.com
  url: https://www.benoitpatra.com
author_login: benoitpatra
author_email: benoit.patra@gmail.com
author_url: https://www.benoitpatra.com
wordpress_id: 2006
wordpress_url: http://benoitpatra.com/?p=2006
date: '2017-04-23 15:21:07 +0000'
date_gmt: '2017-04-23 15:21:07 +0000'
categories:
- Programming
- Database
tags:
- azure
- DocumentDB
- nosql
- CosmosDB
- BigData
comments:
- id: 31338
  author: Rahul
  author_email: rahulsahay19@hotmail.com
  author_url: https://myview.rahulnivi.net
  date: '2018-09-05 06:15:17 +0000'
  date_gmt: '2018-09-05 06:15:17 +0000'
  content: "Hi,\r\n\r\nThis is nice. But just wanted to check in-premise option for
    storing app-insights. Till the time internet connectivity is there, app can log
    insights in azure, which is fine. But, how about storing these offline when there
    is no connectivity.\r\n\r\nWhile testing I saw, when I remove app-insights key
    from app-settings.json, it does emitting values locally, which I can see in app-insights
    which is baked in inside visual studio. Hence, wanted to check whether any option
    is there where in these insights can be saved locally so that these offline data
    can be visualized later also. I have also attached pic for the network. \r\n\r\nThanks,\r\nRahul"
- id: 31345
  author: Benoit Patra
  author_email: benoit.patra@gmail.com
  author_url: https://www.benoitpatra.com
  date: '2018-09-05 08:00:12 +0000'
  date_gmt: '2018-09-05 08:00:12 +0000'
  content: |-
    Hi Rahul,

    I switched completly to other topics, I do not have any longer any visual studio on my Linux machine. I do not believe that app-insights was developed to support local development. Sorry for not being able to bring more help, maybe you could ask directly people at MS Azure. The question is interesting, you should consider posting to Stackoverflow.

    Best
---
<p>Following Wikipedia, <a href="https://en.wikipedia.org/wiki/DocumentDB">DocumentDB</a>&nbsp;(now CosmosDB) is</p>
<blockquote><p>Microsoft&rsquo;s multi-tenant distributed database service for managing JSON documents at Internet scale.</p></blockquote>
<p>The throughput of the database is charged and measured in <em>request unit per second</em> (RUs). Therefore, when creating application on top of DocumentDB, this is a very important dimension that you should pay attention to and monitor carefully.</p>
<p>Unfortunately, at the time of the writing the Azure portal tools to measure your RUs usage are very poor and not really usable. You have access to tiny charts where granularity cannot be really changed.</p>
<p>[caption id="attachment_2011" align="alignnone" width="968"]<a href="/assets/images/legacy-wp-content/2017/04/azure.jpg"><img class="size-full wp-image-2011" src="/assets/images/legacy-wp-content/2017/04/azure.jpg" alt="DocumentDB monitoring charts in Azure Portal" width="968" height="877" /></a> These are the only monitoring charts available in the Azure Portal[/caption]</p>
<p>In this blog post, I show how <a href="https://azure.microsoft.com/en-us/services/application-insights/">Application Insights Analytics</a> can be used to monitor the RUs consumption efficiently. This is how we monitor our collections now at <a href="https://keluro.com/">Keluro</a>.</p>
<p>Let us start by presenting Application Insights, it defines itself <a href="https://docs.microsoft.com/en-us/azure/application-insights/app-insights-overview">here</a> as</p>
<blockquote><p>an extensible Application Performance Management (APM) service for web developers on multiple platforms. Use it to monitor your live web application. It will automatically detect performance anomalies. It includes powerful analytics tools to help you diagnose issues and to understand what users actually do with your app.</p></blockquote>
<p>Let us show how to use it in a C# application that is using the DocumentDB .NET SDK.</p>
<p>First you need to install the <a href="https://www.nuget.org/packages/Microsoft.ApplicationInsights">Application Insights Nuget Package</a>. Then, you need to track the queries using a <em>TelemetryClient</em> object, see a sample code below.</p>
<p>[code language="csharp"]<br />
public static async Task<FeedResponse<T>> LoggedFeedResponseAsync<T>(this IQueryable<T> queryable, string infoLog, string operationId)<br />
{<br />
	var docQuery = queryable.AsDocumentQuery();<br />
	var now = DateTimeOffset.UtcNow;<br />
	var watch = Stopwatch.StartNew();<br />
	var feedResponse = await docQuery.ExecuteNextAsync<T>();<br />
	watch.Stop();<br />
	TrackQuery(now, watch.Elapsed, feedResponse.RequestCharge, "read", new TelemetryClient(), infoLog, operationId, feedResponse.ContentLocation);<br />
	return feedResponse;<br />
}</p>
<p>public static void TrackQuery(DateTimeOffset start, TimeSpan duration, double requestCharge, string kind, TelemetryClient tc, string infolog, string operationId, string contentLocation)<br />
{<br />
	var dependency = new DependencyTelemetry(<br />
			"DOCDB",<br />
			"",<br />
			"DOCDB",<br />
			"",<br />
			start,<br />
			duration,<br />
			"0", // Result code : we can't capture 429 here anyway<br />
			true // We assume this call is successful, otherwise an exception would be thrown before.<br />
			);<br />
	dependency.Metrics["request-charge"] = requestCharge;<br />
	dependency.Properties["kind"] = kind;<br />
	dependency.Properties["infolog"] = infolog;<br />
	dependency.Properties["contentLocation"] = contentLocation ?? "";<br />
	if (operationId != null)<br />
	{<br />
		dependency.Context.Operation.Id = operationId;<br />
	}<br />
	tc.TrackDependency(dependency);<br />
}<br />
[/code]</p>
<p>The good news is that you can now effectively keep records of all requests made to DocumentDB. Thanks to a great component of Application Insights named <a href="https://docs.microsoft.com/en-us/azure/application-insights/app-insights-analytics">Analytics</a>, you can browse the queries and see their precise <em>request-charges</em> (the amount of RUs consumed).</p>
<p>You can also add identifiers (with variables such as <em>kind</em> and <em>infolog</em> in sample above) from your calling code for a better identification of the requests. Keep in mind that the request payload is not saved by Application Insights.</p>
<p>In the screenshot below you can list and filter the requests tracked with DocumentDB in Application Insights Analytics thanks to its <a href="https://docs.microsoft.com/en-us/azure/application-insights/app-insights-analytics-tour">amazing querying language to access data</a>.</p>
<p>[caption id="attachment_2013" align="alignnone" width="1189"]<a href="/assets/images/legacy-wp-content/2017/04/analytics_1.jpg"><img class="size-full wp-image-2013" src="/assets/images/legacy-wp-content/2017/04/analytics_1.jpg" alt="Getting all requests to DocumentDB in a a timeframe using application Insights Analytics" width="1189" height="866" /></a> Getting all requests to DocumentDB in a a timeframe using application Insights Analytics[/caption]</p>
<p>There is one problem with this approach is that for now, using this technique and DocumentDB .NET SDK we do not have access to the number of retries (the 429 requests). This is an <a href="https://github.com/Azure/azure-documentdb-dotnet/issues/225">open issue on Github</a>.</p>
<p>Finally, Analytics allows us to create a very important chart. The accumulated RUs per second for a specific time range.<br />
The code looks like the following one.</p>
<p>[code language="sql"]<br />
dependencies<br />
| where timestamp > ago(10h)<br />
| where type == "DOCDB"<br />
| extend requestCharge = todouble(customMeasurements["request-charge"])<br />
| extend docdbkind = customDimensions["kind"]<br />
| extend infolog = customDimensions["infolog"]<br />
| order by timestamp desc<br />
| project  timestamp, target, data, resultCode , duration, customDimensions, requestCharge, infolog, docdbkind , operation_Id<br />
| summarize sum(requestCharge) by bin(timestamp, 1s)<br />
| render timechart<br />
[/code]</p>
<p>And the rendered charts is as follows</p>
<p>[caption id="attachment_2016" align="alignnone" width="1319"]<a href="/assets/images/legacy-wp-content/2017/04/analytics_2.jpg"><img class="size-full wp-image-2016" src="/assets/images/legacy-wp-content/2017/04/analytics_2.jpg" alt="Accumulated Request-Charge per second (RUs)" width="1319" height="802" /></a> Accumulated Request-Charge per second (RUs)[/caption]</p>
